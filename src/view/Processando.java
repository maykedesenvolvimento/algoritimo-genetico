/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package view;

import java.io.FileWriter;
import java.io.PrintWriter;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.Random;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import model.Cidade;

/**
 *
 * @author igors
 */
public class Processando extends javax.swing.JFrame {

    /**
     * Creates new form Processando
     */
    private int MAX = 20;
    private int totalDemanda;
    private String impressao;
    ArrayList<ArrayList<ArrayList<Integer>>> geracao;
    private ArrayList<ArrayList<Integer>> avaliacaoPopulacao;
    private ArrayList<Cidade> cidades;
    private ArrayList<Integer> melhorIndividuo;
    private int capacidadeMamografo;
    private int quantidadeMamografo;
    private int quantidadeCruzamento;
    private boolean elitismo;

    public Processando(ArrayList<Cidade> cidades, int capacidadeMamografo, int quantidadeMamografo, int quantidadeCruzamento, boolean elitismo) {
        initComponents();
        this.cidades = cidades;
        this.quantidadeCruzamento = quantidadeCruzamento;
        this.capacidadeMamografo = capacidadeMamografo;
        this.quantidadeMamografo = quantidadeMamografo;
        this.elitismo = elitismo;
        pbProcesso.setMaximum(quantidadeCruzamento);
        lbValor.setText("0/" + quantidadeCruzamento);
        avaliacaoPopulacao = new ArrayList();
        geracao = new ArrayList();
        lbProcessando.setVisible(false);
        pbProcesso.setVisible(false);
        lbValor.setVisible(false);
        melhorIndividuo = new ArrayList<>();
        melhorIndividuo.add(0);
        melhorIndividuo.add(0);
        melhorIndividuo.add(0);
    }

    private Processando() {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        lbProcessando = new javax.swing.JLabel();
        pbProcesso = new javax.swing.JProgressBar();
        lbValor = new javax.swing.JLabel();
        btnIniciar = new javax.swing.JButton();
        lbIniciar = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setTitle("Processando...");
        setAlwaysOnTop(true);
        setLocation(new java.awt.Point(450, 250));
        setResizable(false);

        lbProcessando.setFont(new java.awt.Font("Tahoma", 1, 12)); // NOI18N
        lbProcessando.setText("Processando...");

        lbValor.setText("0/0");

        btnIniciar.setText("Iniciar");
        btnIniciar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnIniciarActionPerformed(evt);
            }
        });

        lbIniciar.setText("Clique no botão Iniciar!");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addGap(0, 0, Short.MAX_VALUE)
                .addComponent(btnIniciar, javax.swing.GroupLayout.PREFERRED_SIZE, 82, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(155, 155, 155))
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(190, 190, 190)
                        .addComponent(lbValor))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(154, 154, 154)
                        .addComponent(lbProcessando))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(38, 38, 38)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(pbProcesso, javax.swing.GroupLayout.PREFERRED_SIZE, 320, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addGroup(layout.createSequentialGroup()
                                .addGap(105, 105, 105)
                                .addComponent(lbIniciar)))))
                .addContainerGap(42, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(16, 16, 16)
                .addComponent(lbIniciar)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(lbProcessando)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(pbProcesso, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(lbValor)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 24, Short.MAX_VALUE)
                .addComponent(btnIniciar)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void btnIniciarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnIniciarActionPerformed
        // TODO add your handling code here:
        iniciar();
    }//GEN-LAST:event_btnIniciarActionPerformed

    //Probabilidade de seleção dos individuos para cruzamento.
    private boolean probabilidadeSelecao(int valorIndividuo, int total) {
        float valIndividuo = valorIndividuo;
        float valTotal = total;
        float result = (float) (valIndividuo / valTotal) * 1000; 
        int probabilidade = (int) result;
        Random random = new Random();
        int valor = random.nextInt(101);
        
        System.out.println("Valor Inidividuo: " + valorIndividuo);
        System.out.println("Valor Total: " +total);
        System.out.println("Valor Resultado: " + result);
        System.out.println("Probabilidade: " + probabilidade);
        System.out.println("Valor Selecionado: " + valor);
        
        if (valor <= probabilidade) {
            return true;
        } else {
            return false;
        }

    }

    //Método para gerar novos indivíduos.
    private ArrayList<ArrayList<Integer>> cruzamento(ArrayList<Integer> pai1, ArrayList<Integer> pai2) {
        ArrayList<ArrayList<Integer>> prole = new ArrayList<>();
        ArrayList<Integer> filho = new ArrayList<>();
        ArrayList<Integer> mascara = gerarMascara();
        for (int i = 0; i < mascara.size(); i++) {
            if (mascara.get(i) == 1) {
                filho.add(pai1.get(i));
            } else {
                filho.add(pai2.get(i));
            }
        }
        prole.add(filho);
        filho = new ArrayList<>();
        for (int i = 0; i < mascara.size(); i++) {
            if (mascara.get(i) == 0) {
                filho.add(pai1.get(i));
            } else {
                filho.add(pai2.get(i));
            }
        }
        prole.add(filho);

        return mutacao(prole);
    }

    //Proporciona uma probabilidade de mutação na prole.
    private ArrayList<ArrayList<Integer>> mutacao(ArrayList<ArrayList<Integer>> prole) {
        for (int i = 0; i < prole.size(); i++) {
            Random random = new Random();
            int probabilidade = random.nextInt(1001);
            if (probabilidade <= 50) {
                int posicaoMutacao = random.nextInt(prole.get(i).size());
                if (prole.get(i).get(posicaoMutacao) == 0) {
                    prole.get(i).set(posicaoMutacao, 1);
                } else {
                    prole.get(i).set(posicaoMutacao, 0);
                }
            }
        }
        return prole;
    }

    //Método principal que inicia todas as operações de backend.
    private void iniciar() {
        try{
            boolean control = false;
        int cont = 1;
        lbIniciar.setVisible(false);
        lbProcessando.setVisible(true);
        pbProcesso.setVisible(true);
        lbValor.setVisible(true);

        imprimirInicial();
        gerarPopulacao();
        avaliacao(geracao.get(cont-1)); 
        restricaoDemanda(cont-1);
        
        if (geracao.get(0).size() > 4) {

            JOptionPane.showMessageDialog(this, "Processo iniciado!");
            ArrayList<ArrayList<Integer>> prole = new ArrayList();
            geracao.add(prole);
            for (int i = 0; i < quantidadeCruzamento; i++) {
                avaliacao(geracao.get(cont-1));
                restricaoDemanda(cont-1);
                melhorIndividuo(cont-1);
                impressaoDados(geracao.get(cont-1), cont-1);
                pbProcesso.setValue(i + 1);
                lbValor.setText(i + 1 + "/" + quantidadeCruzamento);
                
                for (int j = 0; j < (geracao.get(cont-1).size()) / 2; j++) {
                    ArrayList<Integer> pai1 = selecao(cont-1);
                    ArrayList<Integer> pai2 = selecao(cont-1);
                    while (pai1.equals(pai2)) {
                        pai2 = selecao(i);
                    }
                    if (pai1 != null && pai2 != null) {
                        prole = cruzamento(pai1, pai2);
                        geracao.get(cont).add(prole.get(0));
                        geracao.get(cont).add(prole.get(1));
                        control = true;
                    }
                }
                if(control){
                    cont++;
                    control = false;
                    prole = new ArrayList();
                    geracao.add(prole);
                }
            }

            buscarMelhorResultado();
            imprimirResultado();
            this.dispose();
        } else {
            JOptionPane.showMessageDialog(this, "Não existe população necessária para o processamento!\nVerifique as entradas de dados!", "Algoritmo Genético", JOptionPane.WARNING_MESSAGE, null);
            dispose();
        }
        }
        catch(Exception ex){
            throw ex;
        }
        
    }

    //Método para selecionar os indivíduos para o crusamento.
    private ArrayList<Integer> selecao(int posicaoGeracao) {
        for (int i = 0; i < avaliacaoPopulacao.get(posicaoGeracao).size(); i++) {
            if (probabilidadeSelecao(avaliacaoPopulacao.get(posicaoGeracao).get(i), calcularTotal(posicaoGeracao))) {
                return geracao.get(posicaoGeracao).get(i);
            }
        }
        return null;
    }

    //Somatório de todas as soluções de uma geração
    private int calcularTotal(int posicaoGeracao) {
        int total = 0;
        for (int i = 0; i < avaliacaoPopulacao.get(posicaoGeracao).size(); i++) {
            total += avaliacaoPopulacao.get(posicaoGeracao).get(i);
        }
        return total;
    }

    //Elimina todos os individuos que estrapolam o valor máximo de cobertura
    private void restricaoDemanda(int posicaoGeracao) {
        for (int i = 0; i < geracao.get(posicaoGeracao).size(); i++) {
            if (avaliacaoPopulacao.get(posicaoGeracao).get(i) > quantidadeMamografo * capacidadeMamografo) {
                geracao.get(posicaoGeracao).remove(i);
                avaliacaoPopulacao.get(posicaoGeracao).remove(i);
                
            }
        }
    }

    //Retorna a melhor solução.
    private void buscarMelhorResultado() {
        int melhorSolucao = 0;
        int posicaoGeracao = 0;
        int posicaoSolucao = 0;
        for (int i = 0; i < avaliacaoPopulacao.size(); i++) {
            for (int j = 0; j < avaliacaoPopulacao.get(i).size(); j++) {
                if (avaliacaoPopulacao.get(i).get(j) > melhorSolucao) {
                    melhorSolucao = avaliacaoPopulacao.get(i).get(j);
                    posicaoGeracao = i;
                    posicaoSolucao = j;
                }
            }
        }
        impressao += "\n#================================================#\n";
        impressao += "Melhor Solução: " + melhorSolucao + " // Geração: " + posicaoGeracao + " Solução: " + posicaoSolucao;
        impressao += "\n#============ Cidades Selecionadas ==============#\n\n";
        ArrayList<Integer> individuo = geracao.get(posicaoGeracao).get(posicaoSolucao);
        for (int i = 0; i < individuo.size(); i++) {
            if (individuo.get(i) == 1) {
                impressao += "ID: " + cidades.get(i).getId() + "\n";
                impressao += "Nome: " + cidades.get(i).getNome() + "\n";
                impressao += "UF: " + cidades.get(i).getUF() + "\n";
                impressao += "Demanda: " + cidades.get(i).getDemandaMamografo() + "\n";
                impressao += "#===================================#\n";
            }
        }

    }

    private void melhorIndividuo(int posicaoGeracao) {
        int melhorSolucao = 0;
        if (elitismo) {
            for (int j = 0; j < avaliacaoPopulacao.get(posicaoGeracao).size(); j++) {
                if (avaliacaoPopulacao.get(posicaoGeracao).get(j) > melhorSolucao) {
                    melhorSolucao = avaliacaoPopulacao.get(posicaoGeracao).get(j);
                    if (melhorSolucao > melhorIndividuo.get(2)) {
                        melhorIndividuo.set(0, posicaoGeracao);
                        melhorIndividuo.set(1, j);
                        melhorIndividuo.set(2, melhorSolucao);
                    }

                }
            }
            if (melhorSolucao < melhorIndividuo.get(2)) {
                geracao.get(posicaoGeracao).add(geracao.get(melhorIndividuo.get(0)).get(melhorIndividuo.get(1)));
                avaliacaoPopulacao.get(posicaoGeracao).add(melhorIndividuo.get(2));
            }
        }
    }

    //Gera um arquivo .txt com os resultados encotrados.
    private void imprimirResultado() {
        try {
            JFileChooser file = new JFileChooser();
            file.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
            file.showOpenDialog(this);
            FileWriter fileWriter = new FileWriter(file.getSelectedFile().getAbsoluteFile() + "\\resultado" + LocalDate.now() + ".txt");
            PrintWriter gravarArquivo = new PrintWriter(fileWriter);
            gravarArquivo.print(impressao);
            gravarArquivo.close();
            JOptionPane.showMessageDialog(this, "Gravado com sucesso!");

        } catch (Exception ex) {
            JOptionPane.showMessageDialog(this, "Erro ao carregar o arquivo!\n" + ex.getStackTrace(), "Algoritmo Genético", JOptionPane.ERROR_MESSAGE, null);
            System.out.println("Erro:" + ex.getMessage());
        }
    }

    //Cria uma máscara aleatória.
    private ArrayList<Integer> gerarMascara() {
        ArrayList<Integer> mascara = new ArrayList<>();
        for (int i = 0; i < cidades.size(); i++) {
            Random random = new Random();
            int resp = random.nextInt(35000);
            if (resp % 2 == 0) {
                mascara.add(0);
            } else {
                mascara.add(1);
            }

        }
        return mascara;
    }

    //Avalia a capacidade do cromossomo.
    private void avaliacao(ArrayList<ArrayList<Integer>> pop) {
        ArrayList<Integer> avaliacaoCromossomo = new ArrayList();
        for (int j = 0; j < pop.size(); j++) {
            int valor = 0;
            for (int i = 0; i < pop.get(j).size(); i++) {
                if (pop.get(j).get(i) == 1) {
                    valor += cidades.get(i).getDemandaMamografo();
                }
            }
            avaliacaoCromossomo.add(valor);
        }
        avaliacaoPopulacao.add(avaliacaoCromossomo);
    }

    //Impressao de cabeçalho
    private void imprimirInicial() {
        impressao = "#=================== Soluções ===================#\n";
        impressao += "#================================================#\n";
        impressao += "Autor: Igor da Silva Torres// Data: " + LocalDate.now().getDayOfMonth() + "/" + LocalDate.now().getMonth() + "/" + LocalDate.now().getYear() +"\n Capacidade máxima de cobertura: "+quantidadeMamografo*capacidadeMamografo+"\n";
        impressao += "#================================================#\n";
    }

    //Método de impressão de dados relatívos a população.
    private void impressaoDados(ArrayList<ArrayList<Integer>> populacao, int posicaoGeracao) {
        impressao += "#================== Geração " + posicaoGeracao + " =================#\n";
        for (int i = 0; i < populacao.size(); i++) {
            impressao += "Solução " + i + ":";
            for (int j = 0; j < populacao.get(i).size(); j++) {
                impressao += "[" + populacao.get(i).get(j) + "]";
            }
            impressao += "-> Avaliação: " + avaliacaoPopulacao.get(posicaoGeracao).get(i) + "\n";
        }
         impressao += "#================================================#";
        impressao += "\n Total População: " + populacao.size();
        impressao += "\n Total Cidades: " + populacao.get(0).size();
        impressao += "\n\n";

    }

    //Inicia uma população aleatória.
    private void gerarPopulacao() {
        ArrayList<ArrayList<Integer>> populacao = new ArrayList();
        ArrayList<Integer> cromossomo = null;
        for (int j = 0; j < MAX; j++) {
            cromossomo = new ArrayList<>();
            for (int i = 0; i < cidades.size(); i++) {
                Random random = new Random();
                int resp = random.nextInt(35000);
                if (resp % 2 == 0) {
                    cromossomo.add(0);
                } else {
                    cromossomo.add(1);
                }

            }
            populacao.add(cromossomo);
        }
        geracao.add(populacao);
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Processando.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Processando.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Processando.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Processando.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new Processando().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btnIniciar;
    private javax.swing.JLabel lbIniciar;
    private javax.swing.JLabel lbProcessando;
    private javax.swing.JLabel lbValor;
    private javax.swing.JProgressBar pbProcesso;
    // End of variables declaration//GEN-END:variables
}
